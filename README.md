# Dillon-3802-final-project

## Overview

Link to GitHub repo (if not already there): https://github.com/DieselPrius/Dillon-3802-final-project

I started out by writing generate_test_files.py in order to generate input for bubblesort in C and in Python.
My rational for generating random input files instead of generating random input on the fly was because I was trying to compare the 
bubble sort algorithm accross two different langauages (python and C) and didn't know if they would both use the same random number generator 
funtions accross languages. After generating the input files (######.txt files), I then modified the bubblesort.c file I got
from https://www.geeksforgeeks.org/bubble-sort/ to read in the text files to the C bubble sort implementation and timed them for the various
lengths of input and got the following results:

*numbers are in seconds*

C time (100 inputs) - 0 

C time (1000 inputs) - 0

C time (10000 inputs) - 0

C time (100000 inputs) - 26

C time (200000 inputs) - 101

C time (300000 inputs) - 234 


I also ran the vanilla python implementation of bubble sort for n = 100, 1000, 10000 in the Jupyter Notebook, final_project.ipynb.
I got the following results for Vanilla Python:

Vanilla Python (n = 100) -  0.02  seconds

Vanilla Python (n = 1000) -  3.35  seconds

Vanilla Python (n = 10000) -  358.41  seconds


I then moved onto Cython. I learned how to compile Cython code directly from a ".pyx" file and also discovered that it is possible to 
call and run C and C++ code from Cython. As a result, I decided to run the C implementation of bubble sort that I already had defined in
bubblesort.c with n=100000 inputs. For some reason, the call to the C version of bubble sort in Cython ran consistently faster than
directly running the C code itself. As seen above, the pure C implemetation took around 26 seconds each run. The Cython compiled code
took around 11 seconds to run. My best guess is that Cython does some kind of optimizations during the compilation process that somehow
made the Cython generated code faster than the pure C code.

I then started thinking about Bash. I remembered that we had an in-class Bash exercise in which we were experimenting with random number
generation. This then made me wonder if it would have been easier to generate the random number files in Bash than it was in python. 
Conseqeuntly, I decided to write generate_numbers.sh to find out. When compared to the code in generate_test_files.py, it appears that
it is slighly easier to generate the input number files with Bash. The ">>" operator to append to a file combined with the fact that you 
can just chain $RANDOM together with onther $RANDOMs to create a bigger number make the generation very easy.

I then tried to conduct vanilla python runs with n > 100000 inputs on Hamming because they were taking too long to run on my local machine.
I was not succesful with this because I couldn't get the python scripts to properly read from the input txt files when running them as a batch job.
I did, however, learn more about Hamming batch jobs in the process. I learned how to run a Hamming job with a .sh file instead of intslurm and
learned that Hamming will automatically place the output of the batch job into slurm*.out file that you can read later. 

Finally, I decided to upload my code for this final project to GitHub using the command line to get more practice with git commands. 

I ended up going for more of a breadth approach with this project instead of an in-depth Cython analysis, so I ended up not cross comparing
different sorting alogrithms like I originally intended.


## important file descriptions

final_project.ipynb - has time info for some vanilla python runs 

final_project.pyx - cython code. currently calls the C implementation of bubble sort from bubblesort.c directly from python

bubblesort.c - C code for bubblesort taken from https://www.geeksforgeeks.org/bubble-sort/ modified to read input from files generated by generate_test_files.py

generate_test_files.py - generates a list of random numbers of various lengths and writes them to .txt files (for example 100.txt, 1000.txt, ect.) ...
                            this allows input to the sorting arrays to stay consistent between languages and runs

setup.py - used to generate cython code

run.py - run the code generated by cython

generate_numbers.sh - proof on concept script for generating random number output files

bash_numbers.txt - output file for the generate_numbers.sh script


## C commands

compile C code:
    
gcc -Wall bubblesort.c -o bubblesort

run C code:
    
./bubblesort
    
## How to buld and run Cython (code is in final_proejct.pyx):

python setup.py build_ext --inplace

python run.py

## Git Commands used:

git clone https://github.com/DieselPrius/Dillon-3802-final-project.git

git config --global user.name "DieselPrius"

git commit -m "Initial upload of files from my local machine"

***before pushing you must set up your access token: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token

***enter token when prompted for password

git push origin main

git pull

git status